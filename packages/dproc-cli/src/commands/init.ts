import { Command } from "commander";
import fs from "fs/promises";
import path from "path";
import chalk from "chalk";
import ora from "ora";

export const initCommand = new Command("init")
  .description("Initialize a new pipeline")
  .argument("<name>", "Pipeline name")
  .option("-d, --dir <directory>", "Pipelines directory", ".")
  .option("--description <desc>", "Pipeline description")
  .option("--outputs <formats>", "Output formats (comma-separated)", "md,pdf")
  .option("--no-bundle", "Skip bundle file creation")
  .action(
    async (
      name: string,
      options: {
        dir: string;
        description?: string;
        outputs: string;
        bundle: boolean;
      }
    ) => {
      const spinner = ora("Creating pipeline...").start();

      try {
        // Properly resolve the pipeline directory
        const baseDir = path.isAbsolute(options.dir)
          ? options.dir
          : path.resolve(process.cwd(), options.dir);

        const pipelineDir = path.join(baseDir, name);

        await fs.mkdir(pipelineDir, { recursive: true });

        const description = options.description || `${name} report pipeline`;
        const outputs = options.outputs.split(",").map((s) => s.trim());
        const useBundle = options.bundle;

        // Generate config.yml with proper spec: wrapper
        await fs.writeFile(
          path.join(pipelineDir, "config.yml"),
          `spec:
  name: ${name}
  version: 1.0.0
  description: ${description}
  inputs:
    - name: topic
      type: text
      label: Report Topic
      required: true
  outputs:
${outputs.map((o: string) => `    - ${o}`).join("\n")}
  files:
    prompts: prompts.md
    template: template.njk
    mdxTemplate: template.mdx.njk
${useBundle ? `    bundle: bundle.js` : ""}
`,
          "utf-8"
        );

        // ... rest of the files (prompts.md, templates, etc.)

        await fs.writeFile(
          path.join(pipelineDir, "prompts.md"),
          `# Report Generation Prompt

Generate a comprehensive report about: {{ inputs.topic }}

{% if bundle %}
## Available Data
{{ bundle | dump }}
{% endif %}

## Requirements
- Be detailed and thorough
- Use clear structure with headings
- Include relevant examples
- Cite sources where applicable

Generate the report in Markdown format.
`,
          "utf-8"
        );

        await fs.writeFile(
          path.join(pipelineDir, "template.njk"),
          `# {{ inputs.topic }}

{{ report }}

---
*Generated by DProc Framework*
`,
          "utf-8"
        );

        await fs.writeFile(
          path.join(pipelineDir, "template.mdx.njk"),
          `<div className="report">
  <h1>{{ inputs.topic }}</h1>
  
  <div className="content">
    {{ report }}
  </div>
  
  <footer className="text-sm text-gray-500 mt-8 pt-4 border-t">
    Generated by DProc Framework
  </footer>
</div>
`,
          "utf-8"
        );

        if (useBundle) {
          await fs.writeFile(
            path.join(pipelineDir, "bundle.js"),
            `export default async function createBundle(inputs) {
  return {
    topic: inputs.topic,
    timestamp: new Date().toISOString(),
    data: {},
  };
}
`,
            "utf-8"
          );
        }

        await fs.writeFile(
          path.join(pipelineDir, "README.md"),
          `# ${name} Pipeline

${description}

## Usage

### CLI
\`\`\`bash
dproc execute ${name} --input topic="Your topic"
\`\`\`

### Web UI
Select this pipeline from the dropdown and fill the form.
`,
          "utf-8"
        );

        spinner.succeed(
          chalk.green(`Pipeline "${name}" created successfully!`)
        );
        console.log(chalk.cyan(`\nLocation: ${pipelineDir}`));
        console.log(chalk.gray("\nTo use this pipeline:"));
        console.log(
          chalk.gray(`  1. Set PIPELINES_DIR=${baseDir} in your .env`)
        );
        console.log(chalk.gray(`  2. Edit prompts and templates as needed`));
        console.log(chalk.gray(`  3. Run: dproc validate ${name}`));
      } catch (error: unknown) {
        spinner.fail(chalk.red("Failed to create pipeline"));
        const errorMessage =
          error instanceof Error ? error.message : String(error);
        console.error(chalk.red(errorMessage));
        process.exit(1);
      }
    }
  );
